<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>paperplanes. EventMachine, How Does It Work?</title>
    <meta name="robots" content="index,follow"/>
    <meta name="mssmarttagspreventparsing" content="true"/>
    <link rel="shortcut icon" href="/images/favicon.gif" type="image/gif" />
    <link rel="icon" href="/images/favicon.gif" type="image/gif" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  	<meta name="author" content="Mathias Meyer"/>
    <meta name="dc.title" content="paperplanes. EventMachine, How Does It Work?"/>
  	<link rel="start" href="http://www.paperplanes.de" title="paperplanes"/>
     
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="EventMachine, How Does It Work?"/>
    <meta name="twitter:site" content="@roidrage"/>
    <meta name="twitter:creator" content="@roidrage"/>
    <meta name="twitter:description" content="At this year&#39;s Scottish Ruby Conference, I gave a talk about
EventMachine, slides are available.
Amidst the hype around Node.js it&#39;s too easy to forget that Ruby has had evented I/O librari..."/>
    <meta name="twitter:url" content="http://www.paperplanes.de/2011/4/25/eventmachine-how-does-it-work.html"/>
    <meta name="twitter:domain" content="paperplanes.de"/>
    
    <link href="http://www.paperplanes.de/rss.xml" rel="alternate" title="Primary Feed" type="application/rss+xml" />
    <link href="/stylesheets/screen.css" media="screen" rel="Stylesheet" title="paperplanes" type="text/css" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/mobile.css" media="handheld, only screen and (max-device-width: 960px)" />
  </head>
  
  <body id="www-paperplanes-de">
    <div id="head">
      <div id="header-content">
        <a href="/">
          <img src="/images/paperplane.png" id="paperplane">
        </a>
        <div id="about">
          <h1 class="default">Hi, I'm Mathias Meyer, nice to meet you!</h1>
          <h1 class="mobile">Hi, I'm <a href="https://twitter.com/roidrage">Mathias Meyer</a>, I'm the CEO at <a href="https://travis-ci.com">Travis CI</a></h1>
          <p style="color: white" class="about-sub-title default">
            I'm the CEO at <a href="http://travis-ci.com">Travis CI</a>. I like coffee, <a href="https://twitter.com/roidrage">Twitter</a> and <a href="mailto:meyer@paperplanes.de">email</a>.
          </p>
        </div>
      </div>
    </div>

    <div id="box">
      <div id="content">
        <article class="hentry">
  <div class="item_perma">
    <div class="item_details">
      <header>
        <h3 class="entry-title">EventMachine, How Does It Work?</h3>
        <h4><a href="/2011/4/25/eventmachine-how-does-it-work.html" title="Permalink for this post">25 April 2011</a> by <a href="http://twitter.com/roidrage">Mathias Meyer</a></h4>
      </header>
    </div>
    <div class="item_content">
      <p>At this year&#39;s <a href="http://scottishrubyconference.com/">Scottish Ruby Conference</a>, I gave a talk about
<a href="http://rubyeventmachine.com">EventMachine</a>, <a href="http://eventmachine-scotrubyconf.heroku.com/">slides</a> are available.
Amidst the hype around Node.js it&#39;s too easy to forget that Ruby has had evented I/O libraries for years.
<a href="http://rubyeventmachine.com">EventMachine</a>, <a href="http://tinyclouds.org/libebb/">libebb</a>, <a href="http://rev.rubyforge.org/">rev</a>,
<a href="http://coolio.github.com/">cool.io</a>, to name a few. As a general introduction I recommend reading <a href="http://www.kegel.com/c10k.html">Dan Kegel&#39;s article
on the C10K problem</a>, the problem of handling 10000 server connections on a single
machine. It introduces all the evented approaches that have been implemented in the different operating systems over the
last some 15 years.</p>

<p>In preparation for the talk I got curious about EventMachine&#39;s innards. So I thought it&#39;d be nice to share my findings
with you. Node.js kids, pay attention, this concerns you as well. It may be JavaScript, but in the end Node.js works in
a similar fashion, though it builds on <a href="http://software.schmorp.de/pkg/libev.html">libev</a>, which does most of the
plumbing for the different operating system implementations of non-blocking I/O.</p>

<p>Most of the magic happens inside the C++ part of EventMachine, so now&#39;s as good a time as any to dig into it and find
out how it works. There&#39;ll be code in here, not assembler, but I&#39;ll be throwing constants, standard library functions
and TCP networking bits (from C, not from Ruby) at you. There&#39;s no magic however, and when in doubt, consult the man
pages. You do know about man pages, right? They&#39;re awesome.</p>

<h3>while(true): The Event Loop</h3>

<p>EventMachine is based on the idea of an event loop, which is basically nothing more than an endless loop. The standard
snippet of code you&#39;re wrapping all your evented code is this:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">EM.run do
  # go forth and handle events
end
</code></pre></div>
<p>You can look at the details of what the method does in <a href="https://github.com/eventmachine/eventmachine/blob/bd77b0503557de565d3cc9b629ab260b4055bc9d/lib/eventmachine.rb#L185-240">its full
glory</a>.
Other than initializing some things, it dives down into the C++ layer immediately, and it&#39;s where most of the magic
happens from now on.</p>

<p>Three C/C++ extension files are of importance,
<a href="https://github.com/eventmachine/eventmachine/blob/6f7885166746e4dca124780432c8315cd57ca89d/ext/rubymain.cpp"><code>ext/rubymain.cpp</code></a>
is the bridge between Ruby and the C code layer. It uses Ruby&#39;s C functions, mostly to convert datatypes for the later
below. It then calls into code defined in
<a href="https://github.com/eventmachine/eventmachine/blob/6f7885166746e4dca124780432c8315cd57ca89d/ext/cmain.cpp"><code>ext/cmain.cpp</code></a>,
which in turn bridges the C and the C++ code.</p>

<p>When you call <code>EM.run</code> to start the event loop, it calls down into the C layer to <code>t_run_machine_without_threads</code>, which
is called as <code>run_machine</code>, and which in turn calls
<a href="https://github.com/eventmachine/eventmachine/blob/6f7885166746e4dca124780432c8315cd57ca89d/ext/em.cpp#L427"><code>EventMachine_t::Run()</code></a>,
whose interesting bits are shown below.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"> while (true) {
   _UpdateTime();
   if (!_RunTimers())
     break;

  _AddNewDescriptors();
  _ModifyDescriptors();

  if (!_RunOnce())
    break;
  if (bTerminateSignalReceived)
    break;
}
</code></pre></div>
<p>There&#39;s your event loop, doesn&#39;t look that scary now, right? It basically does five things:</p>

<ul>
<li><p>Update the current time (line 2)</p>

<p>Used in the next step to determine whether a timer should be fired</p></li>
<li><p>Run configured timers (line 3)</p>

<p>All the timers specified through either <code>add_timer</code> or <code>add_periodic_timer</code> are run here. When you add a timer,
EventMachine stores it in a map indexed with the time it&#39;s supposed to fire. This makes checking the list for the ones
that should be fired in the current iteration a cheap operation.</p>

<p><a href="https://github.com/eventmachine/eventmachine/blob/6f7885166746e4dca124780432c8315cd57ca89d/ext/em.cpp#L1008"><code>_RunTimers()</code></a>
iterates over the list of timers until it reaches one entry whose key (i.e. the time it&#39;s supposed to fire) is higher
than the current time. Easy and efficient.</p>

<p>On a side note, <code>_RunTimers</code> always returns true, so it&#39;s a bit weird that the return value is checked.</p></li>
<li><p>Add new descriptors (line 6)</p>

<p>Whenever you open a new server connection, EventMachine adds an object representing the connection and the associated
callbacks to this list. All connections and descriptors created in the last iteration are handled, which basically
includes setting additional options if applicable and add them to the list of active connections.</p>

<p>On the operating system level a descriptor represents a file handle or a socket connection.  When you open a file,
create a connection to another machine or create a server to listen for incoming connections, all of them are
represented by descriptors, which are basically integers pointing into a list maintained by the operating system.</p></li>
<li><p>Modify descriptors (line 7)</p>

<p>Modify existing descriptors, if applicable. This only has any effect when you&#39;re using epoll, which we&#39;ll get to
later.</p></li>
<li><p>Run the event (line 9)</p>

<p>Check all open file descriptors for new input. Read whatever&#39;s available, run the associated event callbacks. The
heart of the event loop, worth taking a closer look below.</p></li>
</ul>

<p>The event loop really is just an endless loop after all.</p>

<h3>Open a Socket</h3>

<p>When you call <code>EM.connect</code> to open a connection to a remote server, the connection will be immediately created, but it
may not finish until later. The resulting connection will have a bunch of properties:</p>

<ul>
<li><p>The descriptor is configured to not block on input and output by setting the socket option <code>O_NONBLOCK</code>. This way
reads will immediately return when there&#39;s no data instead of waiting for some to arrive, and writes don&#39;t necessarily
write all the data they&#39;re given. It also means that a call to
<a href="http://www.kernel.org/doc/man-pages/online/pages/man2/connect.2.html"><code>connect()</code></a> to create a new connection returns
before it&#39;s fully created.</p></li>
<li><p>The Nagle algorithm is disabled to prevent the TCP stack from delaying sending packets by setting <code>TCP_NODELAY</code> on the
socket. The operating system wants to buffer output to send fewer packets. Disabling Nagle causes any writes to be
sent immediately. As EventMachine does internal buffering, it&#39;s preferrable for the data to be really sent when it&#39;s
eventually written to a socket.</p></li>
<li><p>Reuse connections in <code>TIME_WAIT</code> state before they&#39;re fully removed from the networking stack. TCP keeps connections
around for a while, even after they&#39;re closed to ensure that all data from the other side really, really made it to
your end. Nice and all, but in environments with a high fluctuation of connnections, in the range of hundreds to
thousands per second, you&#39;ll run out of file descriptors in no time.</p></li>
</ul>

<p>Opening a socket is an immediate event, it happens as soon as you create a new connection. Running any callbacks on it
won&#39;t happen until the next iteration of the event loop. That&#39;s why it&#39;s safe to e.g. fire up a new HTTP request and
then attach callbacks to it. Even if that wouldn&#39;t be the case, EventMachine&#39;s
<a href="https://github.com/eventmachine/eventmachine/blob/master/docs/DEFERRABLES">Deferrables</a> (not to be confused with
<code>EM.defer</code>) ensure that callbacks are fired even after the original event fired, when they&#39;re added at a later time.</p>

<p>What is immediately called, though, is the <code>post_init</code> method on the connection object.</p>

<p>Opening a network connection is just one thing you can do with EventMachine, but as it&#39;s the one thing you&#39;re most
likely to do when you&#39;re using it, let&#39;s leave it at that.</p>

<h3>Don&#39;t call us, we&#39;ll call you</h3>

<p>Working with asynchronous code in EventMachine usually involves callbacks, unless you work with your own connection
class. Libraries like <a href="https://github.com/igrigorik/em-http-request"><code>em-http-request</code></a> rely on deferrables to
communicate with your application. They&#39;re fired when a HTTP request finished or failed. But how does a library keep
track of data that only comes in bit by bit?</p>

<p>The answer is simply buffering. Which brings us to the core of the event loop, checking sockets for input, which is done
from the ominous <code>_RunOnce()</code> method in the code snippet above. EventMachine can utilize three mechanisms to check
descriptors for new input.</p>

<h3>select(*)</h3>

<p>The default is using <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/select.2.html"><code>select()</code></a>, a standard
system call to check a collection of file descriptors for input, by way of Ruby&#39;s implementation <code>rb_thread_select()</code>,
which wraps the call to <code>select()</code> with a bunch of code ensuring thread safety.</p>

<p>Using <code>select()</code> pretty much works everywhere, and is perfectly fine up to a certain number of file descriptors. If
you&#39;re simply serving an asynchronous web application or API using EventMachine, this may be totally acceptable.</p>

<p>Implementing this way of handling I/O is rather straight-forward, if you look at the
<a href="https://github.com/eventmachine/eventmachine/blob/master/ext/em.cpp#L823-957">implementation</a>. Collect all file
descriptors that may be of interest, feed them into select, read and/or write data when possible.</p>

<p>What makes using <code>select()</code> a bit cumbersome is that you always have to assemble a list of all file descriptors for
every call to <code>_RunOnce()</code>, so EventMachine iterates over all registered descriptors with every loop. After select ran,
it loops over all file descriptors again, checking to see if <code>select</code> marked them as ready for reads and/or writes.</p>

<p>When <code>select()</code> marks a descriptor as ready for read or write operations that means the socket will not block when data
is read from or written to it. In the case of reading that usually means the operating system has some data buffered
somewhere, and it&#39;s safe to read that data without having to wait for it to arrive, which in turn would block the call.</p>

<p>Instead of using <code>select()</code>, EventMachine could also use
<a href="http://www.kernel.org/doc/man-pages/online/pages/man2/poll.2.html"><code>poll()</code></a> instead, which just handles a bit nicer in
general, but is not available in the Ruby VM. </p>

<h3>epoll</h3>

<p><a href="https://github.com/eventmachine/eventmachine/blob/master/docs/EPOLL">epoll</a> is Linux&#39; implementation for multiplexing
I/O across a large number of file descriptors.</p>

<p>The basic steps of using epoll are simple:</p>

<ul>
<li><p>Set up an epoll instance using
<a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_create.2.html"><code>epoll_create</code></a>, done initially when the
event loop is created. This creates a virtual file descriptor pointing to a data structure that keeps track of all
real file descriptors associated with it in the next step.</p>

<p>You only need to reference this single file descriptor later, so there&#39;s no need to collect a list of all file
descriptors, as is the case when <code>select()</code> is used.</p></li>
<li><p>Register interest for events on a file descriptor using
<a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_ctl.2.html"><code>epoll_ctl</code></a> on the epoll instance created
above.</p>

<p>This is used in <code>_AddNewDescriptors</code> and <code>_ModifyDescriptors</code> to register and update EventMachine&#39;s file descriptors
with epoll. In fact, both methods only do anything noteworthy when epoll is used. Otherwise they just iterate over a
list of descriptors, pretty much doing nothing with them.</p></li>
<li><p>Wait for input with <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_wait.2.html"><code>epoll_wait</code></a> for a
specified duration. You can wait forever, return immediately if nothing happened, or wait for a specific amount of
time.</p>

<p>EventMachine seems to have chosen to return immediately if there&#39;s no activity. There&#39;s an alternative implementation
calculating the time to wait based on the likelihood of a specific event (e.g a timer firing) to fire on the next
event loop iteration, but it doesn&#39;t seem to ever be used. Seems to be a relict from the time it could also be used as
a C++ library.</p></li>
</ul>

<p>epoll events are registered for both reads and writes, with <code>epoll_wait</code> returning the number of file descriptors that
are ready for both events.</p>

<p>Using epoll has a big advantage, aside from being much more efficient than select in general for larger sets of file
descriptors. It spares code using it the burden of constantly iterating over a list of file descriptors. Instead you
just register them once, and then only iterate over the ones affected by the last call to <code>epoll_wait</code>.</p>

<p>So epoll requires a bit more work when you add or modify connections, but is a bit nicer on the eyes when it comes to
actually polling them for I/O availability.</p>

<p>Note that epoll support must be explicitly enabled using <code>EM.epoll</code>.</p>

<h3>kqueue</h3>

<p>kqueue is the BSD equivalent of epoll, and is available on e.g. FreeBSD and Mac OS X. It works very similar to epoll. If
you want to know more details, I&#39;d suggest <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.79.3925&amp;rep=rep1&amp;type=pdf">reading the paper on it by Jonathan
Lemon</a>.</p>

<p>You can enable kqueue support using <code>EM.kqueue</code>, which is, just like <code>EM.epoll</code>, a noop on systems that don&#39;t support
it. Hopefully future EM versions will use whatever&#39;s available on a particular system as default.</p>

<h3>Call me already!</h3>

<p>All three mechanisms used have one thing in common: when data is read, <code>receive_data</code> is called immediately, which
brings us back to the question of how a connection objects collects data coming in.</p>

<p>Whenever data is ready to be consumed from a socket, EventMachine calls <code>EventDescriptor::Read()</code>, which reads a bunch
of data from the socket, in turn calling <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/read.2.html"><code>read()</code></a>
on the file descriptor, and then immediately executes the callback associated with the descriptor, which usually ends up
calling <code>receive_data</code> with the data that was just read. Note that the callback here refers to something defined on the
C++ level, not yet a Ruby block you&#39;d normally use in an asynchronous programming model.</p>

<p><code>receive_data</code> is where you will usually either buffer data or run some action immediately. em-http-request feeds the
data coming in directly into an HTTP parser. Whatever you do in here, make it quick, don&#39;t process the data for too
long. A common pattern in libraries built on EventMachine is to use a <code>Deferrable</code> object to keep track of a request&#39;s
state, firing callbacks when it either succeeded or failed.</p>

<p>Which brings me to the golden rule of programming with libraries like EventMachine and Node.js: DON&#39;T BLOCK THE EVENT
LOOP!! Defer whatever work you can to a later run of the loop when it makes sense, or push it to another asynchronous
processing facility, e.g. a message queue like RabbitMQ or Redis&#39; Pub/Sub.</p>

<p>In a similar fashion, whenever you write data to a connection using <code>send_data</code>, it&#39;s first buffered, and not actually
sent until the socket is ready for a non-blocking call to
<a href="http://www.kernel.org/doc/man-pages/online/pages/man2/write.2.html"><code>write()</code></a>. Hence all three implementations check
for both read and write availability of a descriptor.</p>

<h3>Fibers vs. Spaghetti</h3>

<p>Where do Ruby&#39;s Fibers come in here? Callbacks can easily lead to spaghetti code, especially when you have to nest them
to run multiple asynchronous actions in succession.</p>

<p>Fibers can stop execution of a process flow at any time and yield control to some other, controlling entity or another
Fiber. You could, for example, wrap a single HTTP request into a fiber and yield back control when all the callbacks
have been assigned.</p>

<p>In the callbacks you then resume the Fiber again, so that processing flow turns into a synchronous, procedural style
again.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">  def get(url)
    Fiber.new do
      current_fiber = Fiber.current
      request = EM::HttpRequest.new(url).get
      request.callback { current_fiber.resume(request) }
      request.errback  { current_fiber.resume(request) }
      Fiber.yield
    end
  end
</code></pre></div>
<p><code>Fiber.yield</code> returns whatever object it was handed in <code>Fiber.resume</code>. Wrap this in a method and boom, there&#39;s your
synchronous workflow. Now all you need to do is call <code>get(&#39;http://paperplanes.de&#39;)</code> and assign something with the return
value. Many props to <a href="http://rubysource.com/understanding-concurrent-programming-with-ruby-goliath/">Xavier Shay for digging into the Goliath
source</a> to find out how that stuff works.
Helped me a lot to understand how that stuff works.  If you never had a proper use case for Fibers in real life, you do
now.</p>

<p><a href="https://github.com/igrigorik/em-synchrony"><code>em-synchrony</code></a> is a library doing just that for a lot of existing EventMachine libraries, and
<a href="http://goliath.io">Goliath</a> is an evented web server, wrapping a Rack-style API using Fibers.</p>

<h3>Things you should be reading</h3>

<p>Here&#39;s a bunch of free reading tips for ya. These books are pretty old, but have gone through some revisions and
updates, and they&#39;re still the classics when it comes to lower level Unix (network) programming and understanding
TCP/IP, which I consider very important. TCP/IP Illustrated is one of the best books I&#39;ve read so far, and I consider it
essential knowledge to be aware of what happens under the networking hood.</p>

<ul>
<li><a href="http://www.amazon.com/gp/product/0201633469/ref=as_li_tf_tl?ie=UTF8&amp;tag=javaddicts-20&amp;linkCode=as2&amp;camp=217145&amp;creative=399353&amp;creativeASIN=0201633469">TCP/IP Illustrated Vol.  1</a></li>
<li><a href="http://www.amazon.com/gp/product/0131411551/ref=as_li_tf_tl?ie=UTF8&amp;tag=javaddicts-20&amp;linkCode=as2&amp;camp=217145&amp;creative=399353&amp;creativeASIN=0131411551">Unix Network Programming</a></li>
<li><a href="http://www.amazon.com/gp/product/0321525949/ref=as_li_tf_tl?ie=UTF8&amp;tag=javaddicts-20&amp;linkCode=as2&amp;camp=217145&amp;creative=399353&amp;creativeASIN=0321525949">Advanced Programming in the Unix
Environment</a></li>
</ul>

<p>Also, read the fine man pages. There&#39;s a whole bunch of good documentation installed on every Unix-style system, and I
linked to a couple of them relevant to this post already. Read it.</p>

<h3>yield</h3>

<p>This concludes today&#39;s whirlwind tour through some of EventMachine&#39;s internals. There&#39;s actually not too much magic
happening under the covers, it&#39;s just wrapped into a bit too much code layering for my taste. But you be the judge.</p>

<p>Play with EventMachine and/or Node.js if you haven&#39;t already, try to wrap your head around the asynchronous programming
model. But for the love of scaling, don&#39;t look at evented and asynchronous I/O as the sole means of scaling, because
it&#39;s not.</p>

    </div>
    <div class="item_meta">
      <div class="item_tags">Tags:
        
      </div>
      <div class="item_hierarchy">Hierarchy:
        
          <a href="/2011/1/10/mongodb_and_data_durability.html" title="Previous post">previous</a>
        
        
        
          , <a href="/2011/7/25/web_operations_101_for_developers.html" title="Next post">next</a>
        
        </div>
    </div>
  </div>
</article>

       
        <div id="footer">
          <div id="footer_text">
            <a href="/archives.html">Archives</a>, <a href="http://www.paperplanes.de/rss.xml" title="Full-text RSS feed">RSS Feed</a>, &copy; 2007-2014 Mathias Meyer <a href="/imprint.html">Imprint</a>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46305173-1', 'paperplanes.de');
      ga('send', 'pageview');

    </script>
  </body>
  <script src="//my.hellobar.com/7db1d1ae6111ae95568efbbf8e6a1ee953ad854f.js" type="text/javascript" charset="utf-8" async="async"></script>
</html>
