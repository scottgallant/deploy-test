<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>paperplanes. MongoDB, Data Durability and Improvements coming in 1.8</title>
    <meta name="robots" content="index,follow"/>
    <meta name="mssmarttagspreventparsing" content="true"/>
    <link rel="shortcut icon" href="/images/favicon.gif" type="image/gif" />
    <link rel="icon" href="/images/favicon.gif" type="image/gif" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  	<meta name="author" content="Mathias Meyer"/>
    <meta name="dc.title" content="paperplanes. MongoDB, Data Durability and Improvements coming in 1.8"/>
  	<link rel="start" href="http://www.paperplanes.de" title="paperplanes"/>
     
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="MongoDB, Data Durability and Improvements coming in 1.8"/>
    <meta name="twitter:site" content="@roidrage"/>
    <meta name="twitter:creator" content="@roidrage"/>
    <meta name="twitter:description" content="Last weekend I tweeted two links to
two
tweets by a poor guy who apparently got his MongoDB
database into an unrecoverable state during shutdown whilst upgrading to a newer version. That tweet quic..."/>
    <meta name="twitter:url" content="http://www.paperplanes.de/2011/1/10/mongodb_and_data_durability.html"/>
    <meta name="twitter:domain" content="paperplanes.de"/>
    
    <link href="http://www.paperplanes.de/rss.xml" rel="alternate" title="Primary Feed" type="application/rss+xml" />
    <link href="/stylesheets/screen.css" media="screen" rel="Stylesheet" title="paperplanes" type="text/css" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/mobile.css" media="handheld, only screen and (max-device-width: 960px)" />
  </head>
  
  <body id="www-paperplanes-de">
    <div id="head">
      <div id="header-content">
        <a href="/">
          <img src="/images/paperplane.png" id="paperplane">
        </a>
        <div id="about">
          <h1 class="default">Hi, I'm Mathias Meyer, nice to meet you!</h1>
          <h1 class="mobile">Hi, I'm <a href="https://twitter.com/roidrage">Mathias Meyer</a>, I'm the CEO at <a href="https://travis-ci.com">Travis CI</a></h1>
          <p style="color: white" class="about-sub-title default">
            I'm the CEO at <a href="http://travis-ci.com">Travis CI</a>. I like coffee, <a href="https://twitter.com/roidrage">Twitter</a> and <a href="mailto:meyer@paperplanes.de">email</a>.
          </p>
        </div>
      </div>
    </div>

    <div id="box">
      <div id="content">
        <article class="hentry">
  <div class="item_perma">
    <div class="item_details">
      <header>
        <h3 class="entry-title">MongoDB, Data Durability and Improvements coming in 1.8</h3>
        <h4><a href="/2011/1/10/mongodb_and_data_durability.html" title="Permalink for this post">10 January 2011</a> by <a href="http://twitter.com/roidrage">Mathias Meyer</a></h4>
      </header>
    </div>
    <div class="item_content">
      <p>Last weekend I <a href="http://twitter.com/#!/roidrage/status/23779182852968449">tweeted two links</a> to
<a href="http://twitter.com/#!/mikemaccana/status/23397112360206337">two</a>
<a href="http://twitter.com/#!/mikemaccana/status/23703196522254337">tweets</a> by a poor guy who apparently got his MongoDB
database into an unrecoverable state during shutdown whilst upgrading to a newer version. That tweet quickly made the
rounds, and the next morning I saw myself staring at replies stating that it was all his fault, because he 1.) used kill
-9 to shut it down because apparently the process hung (my guess is it was in the middle of flushing all data to disk)
and 2.) didn&#39;t have a slave, just one database instance.</p>

<p>Others went as far as <a href="http://twitter.com/#!/MacYET/status/24029811332612096">indirectly calling him an
idiot</a>. Oh interwebs, you make me sad. If you check out the
<a href="http://groups.google.com/group/mongodb-user/t/d0111a47984cb688">thread on the mailing list</a>, you&#39;ll notice a similar
pattern in reasoning. The folks over at <a href="http://learnmongo.com">http://learnmongo.com</a> seem to want to be <a href="http://twitter.com/#!/LearnMongo/status/23917393143140352">the wittiest of them
all</a>, recommending to always have a recent backup, a slave or
replica set and to never <code>kill -9</code> your database.</p>

<p>While you can argue that the guy should&#39;ve known better, there&#39;s something very much at odds here, and it seems to
become a terrifying meme with fans of MongoDB, the idea that you need to do all of these things to get the insurance of
your data being durable. Don&#39;t have a replica? Your fault. <code>kill -9</code> on a database, any database? You mad? Should&#39;ve
read the documentation first, dude. This whole issue goes a bit deeper than just reading documentation, it&#39;s the
fundamental design decision of how MongoDB treats your data, and it&#39;s been my biggest gripe from the get go. I can&#39;t
help but be horrified by these comments.</p>

<p>I&#39;ve heard the same reasoning over and over again, and also that it just hasn&#39;t happened so far, noone&#39;s really lost any
considerable data. The problem is, most people never talk about it publicly, because it&#39;s embarrassing, best proof is
the poor guy above. This issue is not even related to MongoDB, it&#39;s a general problem.</p>

<h3>Memory-Mapped Persistence</h3>

<p>But let me start at the beginning, MongoDB&#39;s persistence cycle, and then get to what&#39;s being done to improve its
reliability and your data&#39;s durability. At the very heart, MongoDB uses <a href="http://en.wikipedia.org/wiki/Memory-mapped_file">memory-mapped
files</a> to store data. A memory-mapped file is a data structure that has
the same representation on disk as it has when loaded into memory. When you access a document in MongoDB, loading it
from disk is transparent to MongoDB itself, it can just go ahead and write to the address in memory, as every database
in MongoDB is mapped to a dynamically allocated set of files on disk. Note that memory-mapped files are something you
won&#39;t find in a lot of other databases, if any at all. Most do their own house-keeping and use custom data structures
for that purpose.</p>

<p>The memory mapping library (in MongoDB&#39;s case the POSIX functions, and whatever Windows offers in that area) will take
care of handling the flush back to disk every 60 seconds (configurable). Everything in between happens solely in memory.
Database crash one second before the flush strikes again? You just lost most of the data that was written in the last 59
seconds. Just to be clear, the flushing cycle is configurable, and you should consider choosing a better value depending
on what kind of data you&#39;re storing.</p>

<p>MongoDB&#39;s much praised insert speed? This is where it comes from. When you write stuff directly to local memory, they
better be fast. The persistence cycle is simple: accept writes for 60 seconds, then flush the whole thing to disk. Wait
for another 60 seconds, then flush again, and so on. Of course MongoDB also flushes the data when you shut it down. But,
and here&#39;s the kicker, of course that flush will fail when you kill it without mercy, using the KILL signal, just like
the poor guy above did apparently. When you kill something that writes a big set binary data to disk, all bets are off.
One bit landing on the wrong foot and the database can get corrupted.</p>

<h3>Database Crashes are Unavoidable</h3>

<p>This scenario can and does happen in e.g. MySQL too, it even happens with CouchDB, but the difference is, that in MySQL
you usually only have a slightly damaged region, which can be fixed by deleting and re-inserting it. In CouchDB, all
that happens is that your last writes may be broken, but CouchDB simply walks all the way back to the last successful
write and runs happily ever after.</p>

<p>My point here is simple: even when killed using the KILL signal, a database should not be unrecoverable. It simply
shouldn&#39;t be allowed to happen. You can blame the guy all you want for using <code>kill -9</code>, but consider the fact that it&#39;s
the process equivalent of a server or even just the database process crashing hard. Which happens, believe it or not.</p>

<p>Yes, you can and probably will have a replica eventually, but it shouldn&#39;t be the sole precondition to get a durable
database. And this is what horrifies me, people seem to accept that this is simply one of MongoDB&#39;s trade-offs, and that
it should just be considered normal. They shouldn&#39;t, it needs more guys like the one causing all the stir bringing up
these isses, even though it&#39;s partly his fault, to show the world what can happen when worse comes to worst.</p>

<p>People need to ask more questions, and not just accept answers like: don&#39;t use kill -9, or always have a replica around.
Servers crash, and your database needs to be able to deal with it.</p>

<h3>Durability Improvements in MongoDB 1.7/1.8</h3>

<p>Now, the MongoDB folks aren&#39;t completely deaf, and I&#39;m happy to report they&#39;ve been working on improvements in the area
of data durability for a while, and you can play with the new durability option <a href="http://www.mongodb.org/downloads">in the latest builds of the 1.7
branch</a>, and just a couple of hours ago, there <a href="https://github.com/mongodb/mongo/commit/6485f8b9f3092bfb2d520adbd54a7809a047cc22">was activity in improving the repair
tools</a> to better deal with corrupted
databases. I welcome these changes, very much so. MongoDB has great traction, a pretty good feature set, and the speed
seems to blow peoples&#39; minds. Data durability has not been one of its strengths though, so I&#39;m glad there&#39;s been a lot
of activity in that area.</p>

<p>If you start the MongoDB server with the new <code>--dur</code> option, and it will start keeping a journal. When your database
crashed, the journal is simply replayed to restore all changes since the last successful flush. This is not a
particularly special idea, because it&#39;s how your favorite relation database has been working for ages, and not unsimilar
to the storage model of other databases in the NoSQL space. It&#39;s a good trade-off between keeping good write speed and
getting a much more durable dataset.</p>

<p>When you kill your database harshly in between flushes with a good pile of writes in between, you don&#39;t lose a lot of
data anymore, maybe a second&#39;s worth (just as you do with MySQL when you use InnoDB&#39;s delayed flushing), if any at all,
but not much more than that. Note that these are observation based on a build that&#39;s now already more than a month old.
Situation may have improved since then. Operations are put into a buffer in memory, from where they&#39;re both logged to
disk into the journal, and then applied to the dataset. When writing the data to memory, it has already been written to
the journal. Journals are rotated once they reach a certain size and it&#39;s ensured that all their data has been applied
to the dataset.</p>

<p>A recovery process applies all uncommitted changes from the log when the database crashes. This way it&#39;s ensured that
you only lose a minimum set of data, if none at all, when your database server crashes hard. In theory the journal could
be used to restore a corrupted in a scenario as outlined above, so it&#39;s pretty neat in my opinion. Either way, the risk
of losing data is now pretty low. In case your curious for code, the magic happens in <a href="https://github.com/mongodb/mongo/blob/master/db/dur.cpp#L419-461">this
method</a>.</p>

<p>I for one am glad to see improvements in this area of MongoDB, and I&#39;m secretly hoping that durable will become the
default mode, though I don&#39;t see it happening for marketing reasons anytime soon. Also, be aware that durability brings
more overhead. In some initial tests however, the speed difference between non-durable and durable MongoDB was almost
not worth mentioning, though I wouldn&#39;t call them representative, but in general there&#39;s no excuse to not use it really.</p>

<p>It&#39;s not yet production ready, but nothing should keep you from playing with it to get an idea of what it does.</p>

<h3>Bottom Line</h3>

<p>It&#39;s okay to accept trade-offs with whatever database you choose to your own liking. However, in my opinion, the
potential of losing all your data when you use <code>kill -9</code> to stop it should not be one of them, nor should accepting
that you always need a slave to achieve any level of durability. The problem is less with the fact that it&#39;s MongoDB&#39;s
current way of doing persistence, it&#39;s with people implying that it&#39;s a seemingly good choice. I don&#39;t accept it as
such. If you can live with that, which hopefully you don&#39;t have to for much longer anyway, that&#39;s fine with me, it&#39;s not
my data anyway. Or maybe I&#39;m just too paranoid.</p>

    </div>
    <div class="item_meta">
      <div class="item_tags">Tags:
        
      </div>
      <div class="item_hierarchy">Hierarchy:
        
          <a href="/2011/1/5/the_virtues_of_monitoring.html" title="Previous post">previous</a>
        
        
        
          , <a href="/2011/4/25/eventmachine-how-does-it-work.html" title="Next post">next</a>
        
        </div>
    </div>
  </div>
</article>

       
        <div id="footer">
          <div id="footer_text">
            <a href="/archives.html">Archives</a>, <a href="http://www.paperplanes.de/rss.xml" title="Full-text RSS feed">RSS Feed</a>, &copy; 2007-2014 Mathias Meyer <a href="/imprint.html">Imprint</a>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46305173-1', 'paperplanes.de');
      ga('send', 'pageview');

    </script>
  </body>
  <script src="//my.hellobar.com/7db1d1ae6111ae95568efbbf8e6a1ee953ad854f.js" type="text/javascript" charset="utf-8" async="async"></script>
</html>
