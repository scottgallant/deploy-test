<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>paperplanes. mathias meyer.</title>
    <meta name="robots" content="index,follow"/>
    <meta name="mssmarttagspreventparsing" content="true"/>
    <link rel="shortcut icon" href="/images/favicon.gif" type="image/gif" />
    <link rel="icon" href="/images/favicon.gif" type="image/gif" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  	<meta name="author" content="Mathias Meyer"/>
    <meta name="dc.title" content="paperplanes. mathias meyer."/>
  	<link rel="start" href="http://www.paperplanes.de" title="paperplanes"/>
    
    <link href="http://www.paperplanes.de/rss.xml" rel="alternate" title="Primary Feed" type="application/rss+xml" />
    <link href="/stylesheets/screen.css" media="screen" rel="Stylesheet" title="paperplanes" type="text/css" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/mobile.css" media="handheld, only screen and (max-device-width: 960px)" />
  </head>
  
  <body id="www-paperplanes-de">
    <div id="head">
      <div id="header-content">
        <a href="/">
          <img src="/images/paperplane.png" id="paperplane">
        </a>
        <div id="about">
          <h1 class="default">Hi, I'm Mathias Meyer, nice to meet you!</h1>
          <h1 class="mobile">Hi, I'm <a href="https://twitter.com/roidrage">Mathias Meyer</a>, I'm the CEO at <a href="https://travis-ci.com">Travis CI</a></h1>
          <p style="color: white" class="about-sub-title default">
            I'm the CEO at <a href="http://travis-ci.com">Travis CI</a>. I like coffee, <a href="https://twitter.com/roidrage">Twitter</a> and <a href="mailto:meyer@paperplanes.de">email</a>.
          </p>
        </div>
      </div>
    </div>

    <div id="box">
      <div id="content">
        <div id="articles">

  <article>
    <div class="item">
      <div class="item_details">
        <h3><a href="/2010/7/5/relational_data_document_databases_schema_design.html">Relational Data, Document Databases and Schema Design</a></h3>
        <h4><a href="/2010/7/5/relational_data_document_databases_schema_design.html" title="Relational Data, Document Databases and Schema Design">05 July 2010</a> by <a href="http://twitter.com/roidrage">Mathias Meyer</a></h4>
      </div>
      <div class="item_content">
        <p>By now it should be obvious that I&#39;m quite fond of alternatives data stores (call them NoSQL if you must). I&#39;ve given
quite a <a href="http://www.paperplanes.de/2010/6/22/june_a_month_of_conferences.html">few talks</a> on the subjects recently, and
had the honor of being a guest on the (German) <a href="http://www.heise.de/developer/artikel/Episode-22-NoSQL-Alternative-zu-relationalen-Datenbanken-1027769.html">heise Developer Podcast on
NoSQL</a>.</p>

<p>There&#39;s some comments and questions that pop up every time alternative databases are being talked about, especially by
people deeply rooted in relational thinking. I&#39;ve been there, and I know it requires some rethinking, and also am quite
aware that there are some controversial things that basically are the exact opposite of everything you learned in
university.</p>

<p>I&#39;d like to address a couple of those with some commentary and my personal experience (Disclaimer: my experience is not
the universal truth, it&#39;s simply that: my experience, your mileage may vary). When I speak of things done in practice,
I&#39;m talking about how I witnessed things getting done in Real Lifeâ„¢, and how I&#39;ve done them myself, both good and bad.
I&#39;m focussing on document databases, but in general everything below holds true for any other kind of non-relational
database.</p>

<p>It&#39;s easy to say that all the nice features document databases offer are just aiming for one thing, to scale up. While
that may or may not be true, it just doesn&#39;t matter for a lot of people. Scaling is awesome, and it&#39;s a problem everyone
wants to solve, but in reality it&#39;s not the main issue, at least not for most people. Also, it&#39;s not an impossible thing
to do even with MySQL, I&#39;ve had my fun doing so, and it sure was an experience, but it can be done.</p>

<p>It&#39;s about getting stuff done. There&#39;s a lot more to alternative databases in general, and document databases in
particular, that I like, not just the ability to scale up. They simply can make my life easier, if I let them. If I can
gain productivity while still being aware of the potential risks and pitfalls, it&#39;s a big win in my book.</p>

<p>What you&#39;ll find, when you really think about it, is that everything below holds true no matter what database you&#39;re
using. Depending on your use case, it can even apply to relational databases.</p>

<p><strong>Relational Databases are all about the Data</strong></p>

<p>Yes, they are. They are about trying to fit your data into a constrained schema, constrained in length, type, and other
things if you see fit. They&#39;re about building relationships between your data in a strongly coupled way, think foreign
key constraints. Whenever you need to add data, you need to migrate your schema. That&#39;s what they do. They&#39;re good at
enforcing a set of ground rules on your data.</p>

<p>See where I&#39;m going with this? Even though relational databases tried to be a perfect fit for data, they ended up being
a pain once that data needed to evolve. If you haven&#39;t felt that pain yet, good for you. I certainly have. Tabular data
sounds nice in theory, and is pretty easy to handle in Excel, but in practice, it causes some pain. A lot of that pain
stemmed from people using MySQL, yes, but take that argument to the guy who wrote it and sold it to people as the nicest
and simplest SQL database out there.</p>

<p>It&#39;s easy to get your data into a schema once, but it gets a lot harder to change the schema and the data into a
different schema at a later point in time. While data sticks around, the schema evolves constantly. Something relational
databases aren&#39;t very good at supporting.</p>

<p><strong>Relational Databases Enforce Data Consistency</strong></p>

<p>They sure do, that&#39;s what they were built for. Constraints, foreign keys, all the magic tricks. Take Rails as a
counter-example. It fostered the idea that all that stuff is supposed to be part of the application, not the database.
Does it have trade-offs? Sure, but it&#39;s part of your application. In practice, that was correct, for the most part,
although I can hear a thousand Postgres users scream. There&#39;s always an area that requires constraints on the database
level, otherwise they wouldn&#39;t have been created in the first place.</p>

<p>But most web applications can live fine without it, they benefit from being free about their data, to shape it in
whichever way they like, adding consistency on the application level. The consistency suddenly lies in your hands, a
responsibility not everyone is comfortable with. You&#39;re suddenly forced to think more about edge cases. But you sure as
hell don&#39;t have to live without consistent data, quite the opposite. The difference is that you&#39;re taking care of the
consistency yourself, in terms of your use case, not using a generic one-fits-all solution.</p>

<p>Relationships between data aren&#39;t always strict. They can be loosely linked, what&#39;s the point of enforcing consistency
when you don&#39;t care if a piece of data still exists or not? You handle it gracefully in your application code if you do.</p>

<p><strong>SQL is a Standard</strong></p>

<p>The basics of SQL are similar, if not the same, but under the hood, there&#39;s subtle differences. Why? Because under
the hood, every relational database works differently. Which is exactly what document databases acknowledge. Every
database is different, trying to put a common language on top will only get you so far. If you want to get the best out
of it, you&#39;re going to specialize.</p>

<p>Thinking in Map/Reduce as CouchDB or Riak force you to is no piece of cake. It takes a while to get used to the ideas
around it and what implications it has for you and your data. It&#39;s worth it either way, but sometimes SQL is just a
must, no question. Business reporting can be a big issue, if your company relies on supporting standard tools, you&#39;re
out of luck.</p>

<p>While standards are important, in the end it&#39;s important what you need to do with your data. If a standard gets in your
way, how is that helpful? Don&#39;t expect a standard query language for document databases any time soon. They all solve
different types of problems in different ways, and they don&#39;t intend to hide that from you with a standard query
language. If on the other hand, all you need is a dynamic language for doing ad-hoc queries, check out
<a href="http://www.mongodb.org">MongoDB</a>.</p>

<p><strong>Normalized Data is a Myth</strong></p>

<p>I learned a lot in uni about all the different kinds of normalization. It just sounded so nice in theory. Model your
data upfront, then normalize the hell out of it, until it&#39;s as DRY as the desert.</p>

<p>So far so good. I noticed one thing in practice: Normalized data almost never worked out. Why? Because you need to
duplicate data, even in e-commerce applications, an area that&#39;s traditionally mentioned as an example where relational
databases are going strong.</p>

<p>Denormalizing data is simply a natural step. Going back to the e-commerce example, you need to store a lot of things
separately when someone places an order: Shipping and billing address, payment data used, product price and taxes, and
so on.  Should you do it all over the place? Of course not, not even in a document database. Even they encourage storing
similar data to a certain extent, and with some of them, it&#39;s simply a must. But you&#39;re free to make these decisions on
your own. They&#39;re not implying you need to stop normalizing, it still makes sense, even in a document database.</p>

<p><strong>Schemaless is not Schemaless</strong></p>

<p>But there&#39;s one important thing denormalization is not about, something that&#39;s being brought up quite frequently and
misunderstood easily. Denormalization doesn&#39;t mean you&#39;re not thinking about any kind of schema. While the word
schemaless is brought up regularly, schemaless is simply not schemaless.</p>

<p>Of course you&#39;ll end up with having documents of the same type, with a similar set of attributes. Some tools, for
instance MongoDB, even encourage (if not force) you to store different types of documents in different collections. But
here&#39;s the kicker, I deliberately used the word similar. They don&#39;t need to be all the same across all documents. One
document can have a specific attribute, the other doesn&#39;t. If it doesn&#39;t, just assume it&#39;s empty, it&#39;s that easy. If it
needs to be filled at some point, write data lazily, so that your schema eventually is complete again. It&#39;s evolving
naturally, which does sound easy, but in practice requires more logic in your application to catch these corner cases.</p>

<p>So instead of running migrations that add new tables and columns, and in the end pushing around your data, you migrate
the data on the next access, whether that&#39;s a read or a write is up to your particular use case. In the end you simply
migrate data, not your schema. The schema will evolve eventually, but first and foremost, it&#39;s about the data, not the
constraints they live in. The funny thing: In larger projects, I ended up doing the same thing with a relational
database. It&#39;s just easier to do and gentler on the load than running a huge batch job on a production database.</p>

<p><strong>No Joins, No Dice</strong></p>

<p>No document database supports joins, simple like that. If you need joins, you have two options: Use a database that
supports joins, or adapt your documents so that they remove the need for joins.</p>

<p>Documents have one powerful advantage: It&#39;s easy to embed other documents. If there&#39;s data you&#39;d usually fetch using a
join, and that&#39;d be suitable for embedding (and therefore oftentimes: denormalizing), there&#39;s your second option. Going
back to the e-commerce example: Whereas in a relational database you&#39;d need a lot of extra tables to keep that data
around (unless you&#39;re serializing it into single column), in a document database you just add it as embedded data to the
order document. You have all the important data one in place, and you&#39;re able to fetch it in one go. Someone said that
relational databases are a perfect fit for e-commerce. Funny, I&#39;ve worked on a market platform, and I&#39;ve found that to be
a ludicrous statement. I&#39;d have benefited from a loser data storage several times, joins be damned.</p>

<p>It&#39;s not always viable, sure, and it&#39;d be foolish to stick with a document database if that&#39;s an important criterion for
your particular use case, then no dice. It&#39;s relational data storage or bust.</p>

<p>Of course there&#39;s secret option number three, which is to just ignore the problem until it&#39;s a problem, just by going
with a document database and see how you go, but obviously that doesn&#39;t come without risks. It&#39;s worth noticing though
that <a href="https://wiki.basho.com/display/RIAK/Riak">Riak</a> supports <a href="https://wiki.basho.com/display/RIAK/Links">links between
documents</a>, and even fetching linked documents together with the parent in
one request. In CouchDB on the other hand, you can emit <a href="http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Keys_and_values">linked
documents</a> in views. You can&#39;t be fully
selective about the document data you&#39;re interested in, but if all you want is fetch linked documents, there is one or
two ways to do that. Also, graph databases have made it their main focus to make traversal of associated documents an
incredibly cheap operation. Something your relational database is pretty bad at.</p>

<p><strong>Documents killed my Model</strong></p>

<p>There&#39;s this myth that you just stop thinking about how to model your data with document databases or key-value storage.
That myth is downright wrong. Just because you&#39;re using schemaless storage doesn&#39;t mean you stop thinking about your
data, quite the opposite, you think even more about it, and in different ways, because you simply have more options to
model and store it. Embedding documents is a nice luxury to have, but isn&#39;t always the right way to go, just like
normalizing the crap out of a schema isn&#39;t always the way to go.</p>

<p>It&#39;s a matter of discipline, but so is relational modelling. You can make a mess of a document database just like you
can make a mess of a relational database. When you migrate data on the fly in a document database, there&#39;s more
responsibility in your hands, and it requires good care with regards to testing. The same is true for keeping track of
data consistency. It&#39;s been moved from the database into your application&#39;s code. Is that a bad thing? No, it&#39;s a sign
of the times. You&#39;re in charge of your data, it&#39;s not your database&#39;s task anymore to ensure it&#39;s correct and valid,
it&#39;s yours. With great power comes great responsibility, but I sure like that fact about document databases. It&#39;s
something I&#39;ve been missing a lot when working with relational databases: The freedom to do whatever the heck I want
with my data.</p>

<p><strong>Read vs. Write Patterns</strong></p>

<p>I just like including this simply because it always holds true, no matter what kind of database you&#39;re using. If you&#39;re
not thinking about how you&#39;re going to access your data with both reads and writes, you should do something about that.
In the end, your schema should reflect your business use case, but what good is that when it&#39;s awkward to access the
data, when it takes joins across several tables to fetch the data you&#39;re interested in?</p>

<p>If you need to denormalize to improve read access, go for it, but be aware of the consequences. A schema is easy to
build up, migrating on the go, but if document databases force you to do one thing, and one thing only, it&#39;s to think
about how you&#39;re reading and writing your data. It&#39;s safe to say that you&#39;re not going to figure it all out upfront, but
you&#39;re encouraged to put as much effort into it as you can. When you find out you&#39;re wrong down the line, you might be
surprised to find that they make it even easier to change paths.</p>

<p><strong>Do your Homework</strong></p>

<p>Someone recently wrote a blog post on why he went back to MySQL from MongoDB, and one of his reasons was that it doesn&#39;t
support transactions. While this is a stupid argument to bring up in hindsight, it makes one thing clear: You need to do
research yourself, noone&#39;s going to do it for you. If you don&#39;t want to live up to that, use the tools you&#39;re familiar
with, no harm done.</p>

<p>It should be pretty clear up front what your business use case requires, and what tools may or may not support you in
fulfilling these requirements. Not all tool providers are upfront about all the downsides, but hey, neither was MySQL.
Read up, try and learn. That&#39;s the only thing you can do, and noone will do it for you. Nothing has changed here, it&#39;s
simply becoming more obvious, because you suddenly have a lot more options to work with.</p>

<p><strong>Polyglot Data Storage</strong></p>

<p>Which brings me to the most important part of them all: Document databases (and alternative, non-relational data stores
in general) are not here to replace relational databases. They&#39;re living alongside of them, with both sides hopefully
somewhat learning from each other. Your projects won&#39;t be about just one database any more, it&#39;s not unlikely you&#39;re
going to end up using two or more, for different use cases.</p>

<p>Polyglot persistence is the future. If there&#39;s one thing I&#39;m certain of, this is it. Don&#39;t let anyone fool you into
thinking that their database is the only one you&#39;ll need, they all have their place.  The hard part is to figure out
what place that is. Again, that&#39;s up to you to find out. People ask me for particular use cases for non-relational
databases, but honestly, there is no real distinction. Without knowing the tools, you&#39;ll never find out what the use
cases are. Other people can just give you ideas, or talk about how they&#39;re using the tools, they can&#39;t draw the line
for you.</p>

<p><strong>Back to the Future</strong></p>

<p>You shouldn&#39;t think of it as something totally new, document databases just don&#39;t hide these things from you. Lots of
the things I mentioned here are things you should be doing anyway, no matter if you&#39;re using a relational or a
non-relational data store. They should be common sense really. We&#39;re not trying to repeat what went wrong in history,
we&#39;re learning from it.</p>

<p>If there&#39;s one thing you should do, it&#39;s to start playing with one of the new tools immediately. I shouldn&#39;t even be
telling you this, since you should hone your craft all the time, and that includes playing the field and broadening your
personal and professional horizon. Only then will you be able to judge what use case is a good fit for e.g. a document
database. I&#39;d highly suggest starting to play with e.g. <a href="http://couchdb.org">CouchDB</a>,
<a href="http://www.mongodb.org">MongoDB</a>, <a href="https://wiki.basho.com/display/RIAK/Riak">Riak</a> or
<a href="http://code.google.com/p/redis">Redis</a>.</p>

      </div>
      <div class="item_meta">
        <span class="item_tags">
          Tags: 
          
        </span>
      </div>
    </div>
  </article>

  <article>
    <div class="item">
      <div class="item_details">
        <h3><a href="/2010/6/29/vim_a_neverending_love_story.html">Vim - A Never-ending Love Story</a></h3>
        <h4><a href="/2010/6/29/vim_a_neverending_love_story.html" title="Vim - A Never-ending Love Story">29 June 2010</a> by <a href="http://twitter.com/roidrage">Mathias Meyer</a></h4>
      </div>
      <div class="item_content">
        <p>About eighteen months ago <a href="/2008/11/4/vim_my_college_sweetheart.html">I wrote about going back to Vim as my daily text
editor</a>. It was a bust, and I went back to TextMate after about a week.</p>

<p>Suddenly it&#39;s the year 2010, and I&#39;m typing this in <a href="http://www.vim.org">Vim</a>. What happened? My itch was re-scratched
if you will. I was wary of some of TextMate&#39;s perceived shortcomings, and honestly I missed having a command and insert
mode. It may sound stupid, but I really prefer that way of working with text and code. TextMate is still a nice
editor, but seeing its development coming to a perceived halt made me realize that Vim is simply forever, not being
developed by just one guy, but a community.</p>

<p>It&#39;s also worth mentioning that I simply started from scratch. Last time I built upon a configuration that grew over the
years, and that included things about whose purpose I just had no idea. I watched the <a href="http://peepcode.com/products/smash-into-vim-i">Smash Into Vim
PeepCode</a> too, and started with the clean slate configuration set that
comes with it. If you&#39;re thinking of getting (back) into Vim, it&#39;s highly recommended, it&#39;s sure to wet your appetite.
There&#39;s also a <a href="http://vimcasts.org/">collection of screencasts</a> and a <a href="http://www.swaroopch.com/notes/Vim">free book on Vim
7</a> available on the interwebs. I have some useful links in <a href="http://delicious.com/pombsd/vim">my bookmark collection
too</a>.</p>

<p>There&#39;s been a lot of developments around scripts for Vim that bring TextMate-like functionality, or that support things
like Cucumber, smart quotes and <a href="http://townk.github.com/vim-autoclose/">auto-closing braces</a>, or even the most awesome
<a href="http://www.vim.org/scripts/script.php?script_id=2975">Git integration</a> you&#39;ll find. But the nicest of them all is
<a href="http://www.vim.org/scripts/script.php?script_id=2332">Pathogen</a>, a script that allows you to keep all your other
scripts in separate places, not losing overview of what&#39;s installed where, and in which version.</p>

<p>Coming from TextMate, you&#39;re gonna miss the &quot;Go To File&quot; dialog, I&#39;m sure. Check out
<a href="http://www.vim.org/scripts/script.php?script_id=3025">Command-T</a>, which does exactly that, only with path-matching
sprinkled on top. It&#39;s not as fast unfortunately, but a lot faster to use than the annoying fuzzy thing I used the last
time I tried to live on Vim. There&#39;s also <a href="http://peepcode.com/products/peepopen">PeepOpen</a>, but it always opens files
in new tabs, and that can get quite annoying, as new Vim tabs are quite different from Vim buffers. For project views I
use <a href="http://www.vim.org/scripts/script.php?script_id=1658">NERDtree</a>, though
<a href="http://www.vim.org/scripts/script.php?script_id=1890">LustyExplorer</a> also seems acceptable.</p>

<p>As I said, I started from scratch, with a clean slate. So the decent thing to do was to put all my <a href="http://github.com/mattmatt/dotvim">Vim configuration
files on GitHub</a>. They include all the scripts I&#39;m using, and my configuration, all
neatly separated into different bundles thanks to Pathogen. There&#39;s a couple of things that are still a bit wonky.
<a href="http://www.vim.org/scripts/script.php?script_id=2050">Lusty Juggler</a> doesn&#39;t work as advertised all the time, though
it&#39;s a neat tool, allowing you to quickly select one of a list of the latest open buffers. RubyTest is quite weird, and
I&#39;m thinking of dumping it completely, and simply rolling my own commands to run tests based on it. The
<a href="http://rails.vim.tpope.net/">rails.vim</a> script package does include some support to run tests too, but not to execute a
single test case.</p>

<p>In general, I haven&#39;t found anything that works in TextMate that you can&#39;t somehow get to work in Vim. Yes, I&#39;ve used
the word somehow. It&#39;s not easy as pie all of the time, and it can be different, heck it&#39;s a different editor. But I
willingly accept that, because as a text editor, I find Vim to be a lot better than TextMate.</p>

<p>I&#39;ve been back on Vim for a month now, and I&#39;m not looking back at all. It&#39;s like coming back to an old friend and
learning what awesome things he&#39;s been up to. It&#39;s pretty much as exciting as playing with new technologies at the
moment. Learning new things can be pretty exciting, even if it&#39;s just another text editor. But it&#39;s not all fun and
giggles. I have some annoyances still, but no editor is perfect. I&#39;m more willing to accept Vim&#39;s for the increased text
surgeon skills than TextMate&#39;s, to be frank. TextMate is still a nice editor, don&#39;t get me wrong, my heart just always
belonged to Vim.</p>

<p>Honestly, I&#39;m more willing to invest my learning time in an editor that I know I can use everywhere than one I can only
use on the Mac with a running user interface. I&#39;m using Vim on every server I&#39;m managing, so why not on my local
machine? Vim makes me think about how I can edit text in the most efficient way possible, and I like that very much. It
even made me map my caps-lock key to control, finally!</p>

<p><em>Update</em>: Was just <a href="http://twitter.com/mutle/status/17356649155">tipped off</a> that PeepOpen can be made to behave
properly and open files in the current MacVim tab.  When you set your MacVim options like in the picture below (notice
the part &quot;Open files from applications&quot;), it works a treat. Thanks, Mutwin!</p>

<p><img src="http://img.skitch.com/20100629-p871pr9ky2fjb7xiubxtt2i2np.jpg" alt="MacVim Options"></p>

      </div>
      <div class="item_meta">
        <span class="item_tags">
          Tags: 
          
        </span>
      </div>
    </div>
  </article>

  <article>
    <div class="item">
      <div class="item_details">
        <h3><a href="/2010/6/24/presentation_fu.html">Presentation Fu</a></h3>
        <h4><a href="/2010/6/24/presentation_fu.html" title="Presentation Fu">24 June 2010</a> by <a href="http://twitter.com/roidrage">Mathias Meyer</a></h4>
      </div>
      <div class="item_content">
        <p>I&#39;ve attended my fair <a href="/2010/6/22/june_a_month_of_conferences.html">share of conferences this month alone</a>, plus a
<a href="http://blog.seedcamp.com/2010/06/yesterdays-mini-seedcamp-berlin-was.html">Seedcamp</a>, and I can safely say that in any
way, I learned a lot about how to build slides, how to keep the audience engaged and things one just shouldn&#39;t do in a
talk or in slides. While I certainly don&#39;t claim to be an expert on the topic now, I just wanted to put all of my
impressions and lessons learned into a post.</p>

<p>I&#39;m definitely not the first person to write about this kind of stuff, a year ago Geoffrey Grosenbach <a href="http://nubyonrails.com/articles/improve-your-technical-slides">wrote on
presenting</a>, and just recently John Nunemaker <a href="http://railstips.org/blog/archives/2010/05/05/improve-your-presentations-in-under-50/">wrote a
post</a> on improving your
presentations for less then $50. Both are well worth reading, but they don&#39;t cover everything I find annoying in
presentations, so there you go.</p>

<h3>Slides</h3>

<p><strong>Keep them small</strong></p>

<p>Seven bullet points per slide is bullshit, that&#39;s way too much. One phrase per slide is a decent rule, though I&#39;m not
  dogmatic about it. One phrase and a couple of short bullet points (not more than four) work from time to time, but not
  all the time. I usually go for a bigger slide set these days, with less content on each slide.</p>

<p>I can run through 80 slides in 45 minutes. I know that sounds like a lot, and I certainly go through them fast, but
  I&#39;d rather give people something to think about than bore them to death. Slides with too much text on it also have the
  negative effect of distracting the audience. They shouldn&#39;t read the slide text, they should be listening to what you
  have to say. Even if you do talk slow, less text on slides is always a good idea. The people should listen to you, not
  try to understand what your slides are saying.</p>

<p>What I usually do is just crank out slides with any text that I&#39;d like to say, and then I go through them one or two
  times to refine and shorten the prases I used to be no more than four or five words for the most part. I also throw
  out slides when I realize they&#39;re disrupting the flow or contain things I&#39;m likely to talk about when I&#39;m on a
  different slide.</p>

<p><strong>Use a large font</strong></p>

<p>Just do it. Not only does it make your slides more readable for everyone in the audience, it forces you to keep the
  information on a single slide short. My headlines are usually 60pt, my subheadings and bullet points around 45pt. The
  bigger the better.</p>

<p>While we&#39;re talking about fonts, avoid italic. It&#39;s a lot harder to read, especially when you mix it with a regular
  font. If you need to emphasize something, just make it bold. Italic fonts disrupt your slides&#39; flow.</p>

<p><strong>Avoid full sentences</strong></p>

<p>Except when you&#39;re quoting someone. Short phrases or even just a single word are much easier to grasp for the
  audience, and they give you a better sense of flow.</p>

<p><strong>Dark text on a bright background</strong></p>

<p>A dark background only works for Steve Jobs, because his team does everything they can to adjust the lighting on
  location for his talk. You on the other end, have to assume the worst. If there&#39;s just a little too much light coming
  into the room, your slides will be unreadable, when you use a dark background. I&#39;ve even seen slides where people
  chose a dark background and just a slightly dark font.</p>

<p>You have no influence on the lighting in the room, and you&#39;ll pretty much just embarrass yourself when your slides are
  unreadable. There&#39;s just no excuse why you shouldn&#39;t just use a light background and a dark font.</p>

<p><strong>Avoid dark photos</strong></p>

<p>Photos are at a similar risk. The more contrast you have in photos you&#39;re using in your preso, the less likely people
  will be able to see them. I tend to not use a lot of photos in my slides anyway, but I just hate having to say: &quot;Geee,
  that&#39;s a bit hard to see, isn&#39;t it?&quot;</p>

<p><strong>Slides are for the people attending the talk</strong></p>

<p>Your slide set should not be focussed on being fully understandable by people who have not attended your talk. You end
  up with so called slideuments, presentations that read like a document. You&#39;re talking for the people attending your
  talk, they probably paid to hear you speak, so focus your energy on giving them a good talk. If you want the rest
  of the world to know about details of your preso, write a blog post or put it into the presenter notes.</p>

<p><strong>Video killed the conference star</strong></p>

<p>I&#39;ve seen video in presentations quite a few times, and honestly, it bores me to death, especially when there&#39;s a
  voiceover on the video. If you must include video, at least talk yourself, taking the audience through whatever
  happens on the screen, especially because you don&#39;t know how the audio is going to be at the venue. I&#39;m well aware
  that live demos are a finnicky thing, but so is video. Not always do you have the luxury of using your own computer to
  do the presentation.</p>

<p><strong>Avoid long code snippets</strong></p>

<p>Code is simply hard to grasp within just a couple of seconds, and it&#39;s awkward trying to explain larger chunks of it.
  Use short snippets instead. If you must include some longer examples, split it up in smaller bits, explaining them one
  by one. I tend to avoid overly complex code snippets. Trying to explain them properly just takes too much time.</p>

<p><strong>Avoid flashy animations</strong></p>

<p>They simply take up valueable time and distract the audience. Even though they&#39;re nice to look at in theory, in
  practice they&#39;re the bane of a well-built presentation. This is true for both transitions between slides and elements
  of a single slide appearing later. Just make them appear, not sparkle or fade in.</p>

<h3>The Talk</h3>

<p><strong>Practice, practice, practice</strong></p>

<p>I find practicing a talk by speaking to myself awkward, not because it&#39;s embarrassing, but simply because of the
  butterflies in my stomach I always end up saying different things in the actual talk. Now, that&#39;s not to say you
  shouldn&#39;t think about what you want to say. I tend to go through my slides several times, going through the things I
  associate with every single one of them, giving me a rough idea and a line of thought on what I want to say. This
  definitely is a lot easier to do when it&#39;s a topic you&#39;ve talked about before, but in general the above has worked
  much better for me.</p>

<p><strong>Drink, drink, drink</strong></p>

<p>It&#39;s a simple fact that talking a lot lets your mouth run dry. I need about half a liter of water to get through a
  talk. Or at least I make sure I have that amount ready. Before you run dry and faint in the midst of your talk, drink,
  it&#39;s not a shameful thing to do, it simply keeps you going. Shame on conference organizers not thinking about having
  drinks ready for their speakers. When in doubt, scout the talks before you and make sure you have a bottle ready
  should it not being taken care of.</p>

<p><strong>Look at the audience, not the big screen</strong></p>

<p>It should be so obvious, yet I&#39;ve just seen people do it again at Cloud Expo. One of the guy&#39;s slides had 14 bullet
  points on it, and the font probably was too small for him to be able to read it from the laptop screen. Another reason
  why I keep my slides short, they&#39;re purpose is to keep me in a flow, to give me short reminders of what I want to talk
  about.</p>

<p><strong>Don&#39;t read your presenter notes</strong></p>

<p>If you need presenter notes to run your talk, you need to practice more. They&#39;re surely useful for people just looking
  at your slides, but if it takes full sentences to keep your talk running, you&#39;ll end up wasting a lot of time trying
  to read what your notes say. Talking freely is a challenge, but the earlier you take it on, the faster you&#39;ll get used
  to it. I&#39;ve seen people use index cards with their presenter notes on them, handwritten, trying to decipher what
  they&#39;ve written on them.</p>

<p>If you know what you&#39;re talking about (at least the slightest bit), you&#39;ll be fine without them, trust me.</p>

<p><strong>Two&#39;s not a company</strong></p>

<p>Having more than one speaker is awkward, especially when one of them is just standing there for most of the time,
  waiting for his turn. Have one up in front at any one time, bring in the next person when it&#39;s his turn. Simple like
  that.</p>

<p><strong>Don&#39;t ask questions</strong></p>

<p>The audience simply won&#39;t answer. If you ask anything, make the audience raise their hands on a topic, but don&#39;t
  expect anyone to answer a specific question. That&#39;s your task. Involving the audience sounds like a good idea, but
  they&#39;re lazy, they want to learn something.</p>

<p><strong>Jokes, tiny bits and stories</strong></p>

<p>Stories and jokes can really lighten up a presentation. Sure, you shouldn&#39;t tell jokes all the time, but something
  sarcastic thrown in from time to time sure can help to wake up the audience. Stories are even better, people love
  benefitting from real life experiences in any way. If it has a happy ending, even better.</p>

<p><strong>Talking slowly is for wimps</strong></p>

<p>The rule of spending two minutes on a slide is bullshit. It would only mean you&#39;d have seven bullet points on a
  particular slide. You shouldn&#39;t rush through anything, and I certainly try to avoid doing that, and it definitely
  depends on the topic you&#39;re talking about, but when I talk about technical things I expect the audience to be curious
  about it and try to keep up. If they can&#39;t, they can always come back to my slides or ask questions. But as always, it
  depends.</p>

<p><strong>Talking fast is for the impatient</strong></p>

<p>If it&#39;s on more generic things that involve higher level topics, or some sort of longer-running workshop, it&#39;s only
  appropriate to walk the people through it and take your time doing so. Usually in these situations it&#39;s a lot easier
  to focus on a single topic. It just depends on how broad your talks topic is.</p>

<p><strong>Take tiny breaks</strong></p>

<p>Should you realize you&#39;re sort of losing track, simply bring yourself back on the rails. Take a tiny break or just
  stop talking. You don&#39;t need to apologize for that. It&#39;s easy to start blabbering on about a certain topic which you
  didn&#39;t even intend to cover in your talk.
  On the other hand, that&#39;s what makes every talk unique, and is exactly why shorter phrases on slides are so much
  better. They keep your brain engaged, making up associations with certain things as you go, and they help keeping a
  talk interesting.</p>

<p>Avoid longer breaks though as people end up being bored, and you&#39;re losing precious time. Longer breaks are usually a
  sign that you&#39;re not as prepared as you should be. If you need to switch in between e.g. slides and a live demo, make
  sure that everything is prepared before the talk.</p>

<p>Talking in front of others is a challenge, no doubt about it, but there&#39;s really no point trying to avoid it, because
the only way to improve your skills is to simply talk in front of people. This is my view of the talking world. I
constantly try to improve on my slides and think about what I&#39;m doing wrong during talks to improve on that. I&#39;ll never
loose the excitement right before a talk, and that&#39;s a good thing. When it becomes routine, you tend to bore people
instead of engaging them. It&#39;s about constantly improving yourself to simply become better at talking in front of
others.</p>

<p>This is my view of giving presentations. Feel free to throw in your ideas, or even to disagree. These guidelines
probably aren&#39;t for everyone, and they might even change for me within just a couple of months, but most of them simply
make sense to me.  I do need to get me a good remote though, since with my larger slide sets, I find myself hitting the
space bar a lot.</p>

      </div>
      <div class="item_meta">
        <span class="item_tags">
          Tags: 
          
        </span>
      </div>
    </div>
  </article>

</div>

<div class="pagination">
  
    
      <a href="/page30" class="previous">Newer Posts</a>
    
  
  
    <a href="/page32" class="next">Older Posts</a>
  
</div>

       
        <div id="footer">
          <div id="footer_text">
            <a href="/archives.html">Archives</a>, <a href="http://www.paperplanes.de/rss.xml" title="Full-text RSS feed">RSS Feed</a>, &copy; 2007-2014 Mathias Meyer <a href="/imprint.html">Imprint</a>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46305173-1', 'paperplanes.de');
      ga('send', 'pageview');

    </script>
  </body>
  <script src="//my.hellobar.com/7db1d1ae6111ae95568efbbf8e6a1ee953ad854f.js" type="text/javascript" charset="utf-8" async="async"></script>
</html>
