<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>paperplanes. mathias meyer.</title>
    <meta name="robots" content="index,follow"/>
    <meta name="mssmarttagspreventparsing" content="true"/>
    <link rel="shortcut icon" href="/images/favicon.gif" type="image/gif" />
    <link rel="icon" href="/images/favicon.gif" type="image/gif" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  	<meta name="author" content="Mathias Meyer"/>
    <meta name="dc.title" content="paperplanes. mathias meyer."/>
  	<link rel="start" href="http://www.paperplanes.de" title="paperplanes"/>
    
    <link href="http://www.paperplanes.de/rss.xml" rel="alternate" title="Primary Feed" type="application/rss+xml" />
    <link href="/stylesheets/screen.css" media="screen" rel="Stylesheet" title="paperplanes" type="text/css" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/mobile.css" media="handheld, only screen and (max-device-width: 960px)" />
  </head>
  
  <body id="www-paperplanes-de">
    <div id="head">
      <div id="header-content">
        <a href="/">
          <img src="/images/paperplane.png" id="paperplane">
        </a>
        <div id="about">
          <h1 class="default">Hi, I'm Mathias Meyer, nice to meet you!</h1>
          <h1 class="mobile">Hi, I'm <a href="https://twitter.com/roidrage">Mathias Meyer</a>, I'm the CEO at <a href="https://travis-ci.com">Travis CI</a></h1>
          <p style="color: white" class="about-sub-title default">
            I'm the CEO at <a href="http://travis-ci.com">Travis CI</a>. I like coffee, <a href="https://twitter.com/roidrage">Twitter</a> and <a href="mailto:meyer@paperplanes.de">email</a>.
          </p>
        </div>
      </div>
    </div>

    <div id="box">
      <div id="content">
        <div id="articles">

  <article>
    <div class="item">
      <div class="item_details">
        <h3><a href="/2011/12/22/holiday-reading-list.html">Holiday Reading List</a></h3>
        <h4><a href="/2011/12/22/holiday-reading-list.html" title="Holiday Reading List">22 December 2011</a> by <a href="http://twitter.com/roidrage">Mathias Meyer</a></h4>
      </div>
      <div class="item_content">
        <p>Here&#39;s a list of things I&#39;ve been reading lately or that I&#39;m about to read, and
that I found to be worth sharing.  If you&#39;re looking for something to read over
the holidays, I&#39;m happy to give you some suggestions. Books, papers, articles,
and videos, something for everyone.</p>

<p><a href="http://scalabilityrules.com/"><strong>Scalability Rules</strong></a></p>

<p>A list of 50 rules related to scalability, in an easy to read recipe style.
They leave some stuff to the imagination, and I don&#39;t agree with every single
rule, especially not with the one that demands software should always be easy
to rollback, but they give you good food for thought for your own
applications. </p>

<p><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf"><strong>Time, Clocks, and the Ordering of Events in a Distributed System</strong></a></p>

<p>The earliest paper (1978!) to mention the notion of clocks as a means to track
ordering of events in distributed systems, the predecessor to vector clocks,
if you will. A must read.</p>

<p><a href="http://radlab.cs.berkeley.edu/people/fox/static/pubs/pdf/c18.pdf"><strong>Harvest, Yield, and Scalable Tolerant Systems</strong></a></p>

<p>A recap of CAP, making the whole notion of it a bit more flexible by adding
tuning knobs for graceful degradation. Hat tip to Coda Hale and his article
<a href="http://codahale.com/you-cant-sacrifice-partition-tolerance/">&quot;You can&#39;t sacrifice partition tolerance&quot;</a> for pointing me to this.</p>

<p><a href="http://dbmsmusings.blogspot.com/2010/04/problems-with-cap-and-yahoos-little.html"><strong>Problems with CAP, and Yahoo&#39;s little known NoSQL system</strong></a></p>

<p>Also related to CAP, this article introduces the notion of PACELC, which
basically adds latency to the CAP equation. CAP has been criticized quite a few
times for being too strict in this regard, and while the name PACELC is a bit
odd, the added notion of latency makes a lot of sense.</p>

<p><a href="http://dbmsmusings.blogspot.com/2011/12/replication-and-latency-consistency.html"><strong>Replication and the latency-consistency tradeoff</strong></a></p>

<p>Another one from Daniel Abadi, another one related to CAP, this time talking
about replication, consistency, and latency.</p>

<p><a href="http://rescomp.stanford.edu/%7Echeshire/rants/Latency.html"><strong>It&#39;s the latency, stupid!</strong></a></p>

<p>Going further back in time, this paper talks about latency in all its glory.
Sure, it talks about modem speed connections, but extrapolate that into today&#39;s
network bandwidth and you still have latency. Or you can read the next posts
too.</p>

<p><a href="http://www.edgeblog.net/2007/its-still-the-latency-stupid/"><strong>It&#39;s Still The Latency, Stupid...pt. 1</strong></a> and <a href="http://www.edgeblog.net/2007/its-still-the-latency-stupid-pt2/"><strong>It&#39;s Still The Latency, Stupid...pt. 2</strong></a></p>

<p>A more recent update on latency, because it still matters more than bandwidth.</p>

<p><a href="http://www.usenix.org/events/hotos03/tech/candea.html"><strong>Crash-only Software</strong></a></p>

<p>I&#39;ve been pondering fault-tolerant and cloud-ready systems for a while now,
here&#39;s one related to the topic, software that crashes as a means to make it
more fault-tolerant.</p>

<p><a href="http://www.infoq.com/presentations/Systems-that-Never-Stop-Joe-Armstrong"><strong>Systems that Never Stop (video)</strong></a></p>

<p>Great talk by Joe Armstrong, inventor of Erlang, laying down six laws for
fault-tolerant systems. All laws lead to Erlang obviously, but it all makes a
lot of sense.</p>

<p><a href="http://www.hpl.hp.com/techreports/tandem/TR-85.7.html"><strong>Why Do Computers Stop and What Can Be Done About It?</strong></a></p>

<p>Related to Joe&#39;s talk, this paper discusses hardware reduncancy and reliable
storage by means of process pairs, modularity and transactions. Have yet to read
this one, but going to be interesting thinking about how these ideas, stemming
from hardware, apply to software and have been implemented by Erlang.</p>

<p><a href="http://workingwithunixprocesses.com/"><strong>Working With Unix Processes</strong></a></p>

<p>A little indie-published ebook on handling Unix processes. Code is focused on
Ruby, but most if not all of the book is easily applicable to any other language
or a basic Unix environment.</p>

<p><a href="http://www.eecs.harvard.edu/%7Emdw/papers/seda-sosp01.pdf"><strong>SEDA: An Architecture for Well-Conditioned, Scalable Internet Services</strong></a></p>

<p>SEDA was an idea for web and application server concurrency based on using
queues to condition and handle requests. While the idea has not exactly made it
through, I found the model to be strikingly similar to the actor model, in a
different way, but still very similar.</p>

<p><a href="http://matt-welsh.blogspot.com/2010/07/retrospective-on-seda.html"><strong>A Retrospective on SEDA</strong></a></p>

<p>SEDA, ten years later, by the author of the original paper. I gotta say, he
talks a lot what they got wrong, but I for one think SEDA had a pretty big
impact on the bigger picture of web application architecture. Probably something
worth discussing in a separate post.</p>

<p><a href="http://www.usenix.org/events/hotos03/tech/full_papers/vonbehren/vonbehren_html/index.html"><strong>Why Events Are A Bad Idea</strong></a></p>

<p>A paper comparing threads and events for highly concurrent servers. I&#39;d
recommend taking this with a grain of salt. A lot has changed since this paper
was written, but what I like about reading papers like this is that it gives you
a historic perspective, same for SEDA.</p>

<p><a href="http://www.redhat.com/magazine/001nov04/features/vm/"><strong>Understanding Virtual Memory</strong></a></p>

<p>Nice summary of how virtual memory works on Linux.</p>

<p><a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2010/EECS-2010-90.pdf"><strong>The Declarative Imperative: Experiences and Conjectures in Distributed Logic</strong></a></p>

<p>To be honest, this is a slightly confusing paper. It starts out modeling things
in an oscure language called Datalog, but then dives into making some
conjectures about distributed logic, which was to me the more interesting part.</p>

<p><a href="http://betathoughts.blogspot.com/2007/06/brief-history-of-consensus-2pc-and.html"><strong>A brief history of Consensus, 2PC and Transaction Commit</strong></a></p>

<p>This article is full of gold. An extraordinarily compact view on the topic, but
with an abundance of links to papers to dive deeper.</p>

<p>Going to keep posting reading lists like this in the future. So much good stuff
to read out there. Lots of great knowledge collected in papers.</p>

<p>Last but not least, why not add the <a href="http://riakhandbook.com/?pp">Riak Handbook</a>
to your reading list as well?</p>

      </div>
      <div class="item_meta">
        <span class="item_tags">
          Tags: 
          
        </span>
      </div>
    </div>
  </article>

  <article>
    <div class="item">
      <div class="item_details">
        <h3><a href="/2011/12/15/storing-timelines-in-riak.html">Storing User Timelines in Riak</a></h3>
        <h4><a href="/2011/12/15/storing-timelines-in-riak.html" title="Storing User Timelines in Riak">15 December 2011</a> by <a href="http://twitter.com/roidrage">Mathias Meyer</a></h4>
      </div>
      <div class="item_content">
        <p>The idea of building and storing user timelines (think Twitter) in Riak confused
me at first. It sounds like such a spot-on case for time series databases. Yet
<a href="http://basho.com/blog/technical/2011/03/28/Riak-and-Scala-at-Yammer/">Yammer</a>
managed to make the idea pretty popular. The whole thing lacked implementation
though, because they kept their to themselves, which I don&#39;t blame them for at
all.</p>

<p><img src="https://img.skitch.com/20111215-kyt2di6kbkwrb1trsquudhy7xa.png" alt="Apple Mac Timeline"></p>

<p>So let&#39;s have a look at how simple it is to build one. You can see a timeline of
all Apple Macintosh products above, but that&#39;s not what we want to build.</p>

<p>Instead we want to build something like the Twitter timeline. A user follows
many other users, and wants to look at a feed built from their activities, so
something like the timeline shown below.</p>

<p><img src="https://img.skitch.com/20111215-qwnywuamtahh356qi9ri3yt9ae.png" alt="Twitter timeline"></p>

<h3>How do you model a timeline in Riak?</h3>

<p>For every user we store one object in Riak. Every timeline contains a list of
tweet ids, or whatever activity you&#39;re referencing, or it can contain the whole
tweets. Something like this should work:</p>

<script src="https://gist.github.com/1481859.js?file=timeline.json"></script>

<p>If you want to store more data, turn the list into an array of hashes containing
whatever information is necessary to rebuild the timeline later. </p>

<script src="https://gist.github.com/1481859.js?file=complex_timeline.json"></script>

<h3>Adding entries to the timeline</h3>

<p>To add new entries to a timeline, prepend them to the existing list of
entries, here&#39;s some Ruby code to show how it&#39;s done.</p>

<script src="https://gist.github.com/1481859.js?file=add_entry.rb"></script>

<p>The code assumes you take care of followership somewhere else. You can store
that data in Riak too, but the code is oblivious to its whereabouts.</p>

<h3>Conflicts, siblings, oh my!</h3>

<p>The fun starts when two clients update the same timeline, you get a conflict
and siblings. The strength of a simple data structure like the example above is
that they&#39;re easy to merge together while still keeping ordering based on the
ids. The ids are ordered only in this example, Twitter somewhat makes sure they
are.</p>

<p>When you get a conflict, a smart Riak library like
<a href="https://github.com/seancribbs/ripple">Ripple</a> helps you find out about it. To
add on the earlier example, here&#39;s a version of <code>add</code> that detects conflicts.</p>

<script src="https://gist.github.com/1481859.js?file=add_conflicts.rb"></script>

<p>Suddenly you have two or more objects instead of one, each containing a different timeline. To
turn them into a single list, you merge all of them together, discard the
duplicates, and restore order based on the id. Here&#39;s some Ruby to do that.</p>

<script src="https://gist.github.com/1481859.js?file=merge_timelines.rb"></script>

<p>You iterate over all timeline objects and keep adding unique activities to a new
list, returning that when done.</p>

<h3>Sort, and done!</h3>

<p>All that&#39;s left to do is sort the result.</p>

<script src="https://gist.github.com/1481859.js?file=add_merge_sort.rb"></script>

<p><a href="http://riakhandbook.com"><img src="https://img.skitch.com/20111213-jks6gqhww79y172qcdsdwpgbgu.png" style="float:right; margin-left: 10px;"></a></p>

<p>There&#39;s the whole code. To spare you the pain of having to write your own
library, all this is bundled into a gem called
<a href="https://github.com/roidrage/riaktivity">riaktivity</a>. If you&#39;re doing Python,
the Brett Hoerner has got you covered with
<a href="https://github.com/bretthoerner/timak">timak</a>. Be sure to watch the original
talk by
<a href="http://basho.com/blog/technical/2011/03/28/Riak-and-Scala-at-Yammer/">Yammer</a>,
it&#39;s well worth it.</p>

<p>There&#39;s ups and downs to this approach, and things that need to be taken care
of. More on that and modeling data for Riak in general is covered in the <a href="http://riakhandbook.com/">Riak
Handbook</a>, the definitive guide on Riak.</p>

      </div>
      <div class="item_meta">
        <span class="item_tags">
          Tags: 
          
        </span>
      </div>
    </div>
  </article>

  <article>
    <div class="item">
      <div class="item_details">
        <h3><a href="/2011/12/13/list-all-of-the-riak-keys.html">List All of the Riak Keys</a></h3>
        <h4><a href="/2011/12/13/list-all-of-the-riak-keys.html" title="List All of the Riak Keys">13 December 2011</a> by <a href="http://twitter.com/roidrage">Mathias Meyer</a></h4>
      </div>
      <div class="item_content">
        <p><img src="https://img.skitch.com/20111213-tkydhksqa79dwhc5ikb9n9g14j.png" alt="Key rack"></p>

<p>One of the most common questions to ask about Riak is: how do I get a list of all
the keys in my bucket, in the cluster, or that have an attribute that matches my
query using MapReduce?</p>

<p>The motivation behind it is simple: you want to delete all the keys in a bucket,
count the amount of keys stored in your cluster entirely, you want to clear out your
cluster or you want to run ad-hoc queries on the data stored in a bucket.</p>

<p>All valid in their own right.</p>

<p>But things are not so simple with Riak. To understand why, let&#39;s take a quick
look under the covers.</p>

<h3>What&#39;s in a bucket?</h3>

<p>A bucket is a namespace in Riak. It&#39;s not a physically distinctive entity like a
table in a relational database. You can set some properties on it, things like
replication levels, commit hooks, quorum, but that&#39;s it. Those are stored in the
cluster&#39;s configuration which is gossiped around the cluster just like the data
that identifies what partition goes on which machine.</p>

<p>In fact, when you specify a bucket and a key to fetch or write some data,
they&#39;re stuck together to find the location in the cluster. Consider a
bucket-key combination like <code>users/roidrage</code>. To find the location, Riak hashes
both, not just the key. Both bucket and key uniquely identify a piece of data,
allowing you to have multiple object with the same key, but in different
buckets.</p>

<p>When an object is stored in Riak&#39;s storage backends, it uses both bucket and key
name to identify it. What you get as a result are files that contain an
abundance of different bucket-key combinations and their respective objects,
sometimes not even in any order. The only physical distinction Riak has for data
on disk is the partition they belong to. Everything else is up to the storage
backend. There&#39;s no distinction between buckets on disk.</p>

<p>One reason for this is consistent hashing. If you remember the <a href="/2011/12/9/the-magic-of-consistent-hashing.html">last installment
of this series</a>, I mentioned
that consistent hashing&#39;s downside is that you lose key ordering. Keys are
randomly spread out through the cluster. Some ordering still exists depending on
the backend, but in general, ordering is lost.</p>

<h3>Listing all of the keys</h3>

<p>So to list keys in a bucket, Riak has to go through all of the keys in every
partition, and I mean ALL OF THEM. Here&#39;s a picture of keys and an impersonation
of Riak, having to take care of all of them.</p>

<p><img src="https://img.skitch.com/20111213-g2ju8pdeefu4ns5q6j7m8smdr1.png" width="540"/></p>

<p>No big deal, right? Unless of course, you store millions and millions of them,
and want to find about all the keys from say, the bucket <code>users</code>, which may not
even have to be more than 1000. To do that, Riak goes through every partition,
every partition loads the keys either from memory (Bitcask) or disk (LevelDB)
and sifts through them, finding the ones belonging to the <code>users</code> bucket.</p>

<p>All that said, it&#39;s certainly not impossible to do, if you have some time to
wait, depending on the amount of data stored.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ curl &#39;localhost:8098/buckets/users/keys?keys=true&#39;
</code></pre></div>
<p>But wait, don&#39;t do that. Do this instead, streaming the keys instead of waiting
for them all to arrive and then having them dumped at once.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ curl &#39;localhost:8098/buckets/users/keys?keys=stream&#39;
</code></pre></div>
<p>That&#39;s much better.</p>

<p>Listing keys has an impact on your Riak nodes, so if you can avoid it, don&#39;t do
it!</p>

<h3>So how do I really get all of the keys?</h3>

<p>If <code>select * from riak</code> is not a great option, then what is?</p>

<p>Instead of relying on Riak, build an index on the keys. Thanks to <a href="http://wiki.basho.com/Secondary-Indexes.html">Riak 2i
(Secondary Indexes)</a>, this is
easy. In fact, you get indexing of keys for free when using the LevelDB backend,
just use the index <code>$key</code>. This takes advantage of LevelDB&#39;s sorted file
structure. Neat!</p>

<p>But, and here&#39;s the kicker, you can only fetch ranges of keys. So instead of
asking for all the keys, you ask for a range large enough to fit all the keys.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$ curl &#39;localhost:8098/buckets/users/index/$key/0/zzzz&#39;
</code></pre></div>
<p>This finds all the keys that start with something lexicographically larger than
<code>0</code> and less than <code>zzzz</code> and returns them to you in a list. Now there&#39;s a slim
chance you&#39;ll get users with names like that, but I&#39;ll leave that exercise, or
proper validations, up to you.</p>

<p>Using that list, you can count the number of keys in that bucket, or you can
delete them one by one.</p>

<h3>Ideally...</h3>

<p><a href="http://riakhandbook.com"><img src="https://img.skitch.com/20111213-jks6gqhww79y172qcdsdwpgbgu.png" style="float:right; margin-left: 10px;"></a></p>

<p>In an ideal world, listing keys in a bucket would be possible and not an
expensive operation. Riak could for example allow users to store buckets in
separate files. The downside is that with a lot of buckets, you&#39;ll hit the
limits of open file descriptors in no time, a bit of a bummer. But until
something better comes along, secondary indexes are a nice tool to at least
avoid resorting to listing all of the keys.</p>

<p>Curious about other ways to index and query data in Riak? You&#39;ll like the <a href="http://riakhandbook.com">Riak
Handbook</a>, which will be published later this
week. Covers Riak&#39;s secondary indexes and other strategies to query, inspect and
analyze data.</p>

<p>Check back in tomorrow for an introduction on storing timelines in Riak.</p>

      </div>
      <div class="item_meta">
        <span class="item_tags">
          Tags: 
          
        </span>
      </div>
    </div>
  </article>

</div>

<div class="pagination">
  
    
      <a href="/page25" class="previous">Newer Posts</a>
    
  
  
    <a href="/page27" class="next">Older Posts</a>
  
</div>

       
        <div id="footer">
          <div id="footer_text">
            <a href="/archives.html">Archives</a>, <a href="http://www.paperplanes.de/rss.xml" title="Full-text RSS feed">RSS Feed</a>, &copy; 2007-2014 Mathias Meyer <a href="/imprint.html">Imprint</a>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46305173-1', 'paperplanes.de');
      ga('send', 'pageview');

    </script>
  </body>
  <script src="//my.hellobar.com/7db1d1ae6111ae95568efbbf8e6a1ee953ad854f.js" type="text/javascript" charset="utf-8" async="async"></script>
</html>
