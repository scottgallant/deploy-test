<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <title>paperplanes. When Overusing self Turns Into self.pity</title>
    <meta name="robots" content="index,follow"/>
    <meta name="mssmarttagspreventparsing" content="true"/>
    <link rel="shortcut icon" href="/images/favicon.gif" type="image/gif" />
    <link rel="icon" href="/images/favicon.gif" type="image/gif" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  	<meta name="author" content="Mathias Meyer"/>
    <meta name="dc.title" content="paperplanes. When Overusing self Turns Into self.pity"/>
  	<link rel="start" href="http://www.paperplanes.de" title="paperplanes"/>
     
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="When Overusing self Turns Into self.pity"/>
    <meta name="twitter:site" content="@roidrage"/>
    <meta name="twitter:creator" content="@roidrage"/>
    <meta name="twitter:description" content="There&#39;s something I see in lots of projects is an overuse of self. Sure, it looks a lot nicer than this, but its overuse can clutter code quite easily. Here&#39;s a rather simple example.
def p..."/>
    <meta name="twitter:url" content="http://www.paperplanes.de/2009/3/13/when_overusing_self_turns_into_self_pity.html"/>
    <meta name="twitter:domain" content="paperplanes.de"/>
    
    <link href="http://www.paperplanes.de/rss.xml" rel="alternate" title="Primary Feed" type="application/rss+xml" />
    <link href="/stylesheets/screen.css" media="screen" rel="Stylesheet" title="paperplanes" type="text/css" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/mobile.css" media="handheld, only screen and (max-device-width: 960px)" />
  </head>
  
  <body id="www-paperplanes-de">
    <div id="head">
      <div id="header-content">
        <a href="/">
          <img src="/images/paperplane.png" id="paperplane">
        </a>
        <div id="about">
          <h1 class="default">Hi, I'm Mathias Meyer, nice to meet you!</h1>
          <h1 class="mobile">Hi, I'm <a href="https://twitter.com/roidrage">Mathias Meyer</a>, I'm the CEO at <a href="https://travis-ci.com">Travis CI</a></h1>
          <p style="color: white" class="about-sub-title default">
            I'm the CEO at <a href="http://travis-ci.com">Travis CI</a>. I like coffee, <a href="https://twitter.com/roidrage">Twitter</a> and <a href="mailto:meyer@paperplanes.de">email</a>.
          </p>
        </div>
      </div>
    </div>

    <div id="box">
      <div id="content">
        <article class="hentry">
  <div class="item_perma">
    <div class="item_details">
      <header>
        <h3 class="entry-title">When Overusing self Turns Into self.pity</h3>
        <h4><a href="/2009/3/13/when_overusing_self_turns_into_self_pity.html" title="Permalink for this post">13 March 2009</a> by <a href="http://twitter.com/roidrage">Mathias Meyer</a></h4>
      </header>
    </div>
    <div class="item_content">
      <p>There&#39;s something I see in lots of projects is an overuse of <code>self</code>. Sure, it looks a lot nicer than <code>this</code>, but its overuse can clutter code quite easily. Here&#39;s a rather simple example.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def published?
 !self.deleted_at? &amp;&amp; self.published_at?
end
</code></pre></div>
<p>Others use self even for just calling a method from another method. Why&#39;s that again? I just don&#39;t get it, it feels unnecessary, and is just five characters too much for every usage.</p>

<p>Sometimes I think that the programmer who wrote the code either doesn&#39;t understand the concept of the current scope of self and when using it is necessary, or is coming from Python (no offense Python, I still like you, but I&#39;m not so fond of your usage of self). Let&#39;s remedy that, shall we?</p>

<p>Some also claim that it improves clarity, for the courtesy of other programmers working on the code, and to make it clearer in what context the method is called. If you need to make that clear, your method is simply too long.</p>

<p>The biggest confusion surrounding the usage of self from within a method stems from the different handling of local variables and method lookup. Consider the following code:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def publish
  self.published_at = Time.now
  save
end
</code></pre></div>
<p>It&#39;s a totally valid piece of code, and one I can totally get on board with, because it does what it&#39;s supposed to do. In my early days with Ruby, I used to write the code like this:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def publish
  published_at = Time.now
  save
end
</code></pre></div>
<p>Then I wondered why the instance variable <code>published_at</code> wasn&#39;t saved. The answer is simple. When you have something that looks like local variable, and you assign to it, Ruby will obey and create a new local variable called <code>published_at</code>, no matter if you have a write accessor defined that looks exactly like it. It will go out of scope as soon as the program&#39;s flow leaves the method.</p>

<p>But what about <code>save</code>? Ruby will first look for a local variable. Now, I&#39;m not arguing that you shouldn&#39;t have a local variable called <code>save</code> anywhere in your program, and if you do you might want to rethink that. But since, for now, there is no local variable with that name, Ruby will turn to its method lookup mechanism to resolve the identifier in question. If it can&#39;t find anything you&#39;ll get the much loved error <code>NoMethodError</code>.</p>

<p>If clarity is what you&#39;re longing for, learn Ruby&#39;s rules of resolving local variables and methods. Will make your life much easier.</p>

<p>So what is Ruby doing in the former version of the method body? You&#39;re pretty much forcing it to go directly to the method lookup. With the accessor magic it will find a method <code>published_at=(published_at)</code> and call it. Easy.</p>

<p>I&#39;ve also seen modifications of this one:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def publish
  self.published_at = Time.now
  self.save
end
</code></pre></div>
<p>Or how about this one:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def publish
  self.published_at = Time.now
  self.publisher = self.user
  self.save
end
</code></pre></div>
<p>What&#39;s up with that? Pretty self-involved if you ask me. It&#39;s like using self just for the sake of it. Using self when assigning to instance variables, so might as well use it everywhere in the method for consistency, right?</p>

<p>Now, imagine that piece of code also having a call to a private or protected method in it. Of course you can&#39;t call those directly on an object, only on an implicit <code>self</code>:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def publish
  self.published_at = Time.now
  update_trackbacks
  self.save
end
</code></pre></div>
<p>Gross! The code looks more and more confusing, and I don&#39;t appreciated confusing looking code.</p>

<p>Of course, if you&#39;re using ActiveRecord, why not save a full line?</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def publish
  update_attribute(:published_at, Time.now)
end
</code></pre></div>
<p>So let&#39;s review the initial example. We&#39;re only doing method calls, and Ruby will figure out our intention all by itself. So how about the simple version:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def published?
 !deleted_at? &amp;&amp; published_at?
end
</code></pre></div>
<p>Wow, so simple. Much easier on the eyes, and the intention is clear right from the start. My rule is simple: When assigning to an instance variable, use self, calling a method on the other hand should stand all by itself. Now, you could argue, that assigning to an instance variable using its accessor is also a method call, but if you really want to argue about that, you should really read this blog entry again.</p>

    </div>
    <div class="item_meta">
      <div class="item_tags">Tags:
        
      </div>
      <div class="item_hierarchy">Hierarchy:
        
          <a href="/2009/3/8/hello_from_jekyll.html" title="Previous post">previous</a>
        
        
        
          , <a href="/2009/3/16/keep_it_simple.html" title="Next post">next</a>
        
        </div>
    </div>
  </div>
</article>

       
        <div id="footer">
          <div id="footer_text">
            <a href="/archives.html">Archives</a>, <a href="http://www.paperplanes.de/rss.xml" title="Full-text RSS feed">RSS Feed</a>, &copy; 2007-2014 Mathias Meyer <a href="/imprint.html">Imprint</a>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-46305173-1', 'paperplanes.de');
      ga('send', 'pageview');

    </script>
  </body>
  <script src="//my.hellobar.com/7db1d1ae6111ae95568efbbf8e6a1ee953ad854f.js" type="text/javascript" charset="utf-8" async="async"></script>
</html>
